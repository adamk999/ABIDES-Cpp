#pragma once
#include <string>
#include <limits>
#include "../util/timestamping.h"
#include <optional>  // For std::optional and std::nullopt
#include "../util/util.h"

class Side {
public:
    // Define the enum class inside the Side class.
    enum class Type {
        BID,
        ASK
    };

    // Constructor to initialise the enum value.
    Side(Type side_type) : side(side_type) {}
    Side() {}

    // Method to check if the side is BID.
    bool is_bid() const {
        return side == Type::BID;
    }

    // Method to check if the side is ASK.
    bool is_ask() const {
        return side == Type::ASK;
    }

    // Convert the enum to string for easier display.
    std::string to_string() const {
        switch (side) {
            case Type::BID:
                return "BID";
            case Type::ASK:
                return "ASK";
            default:
                return "UNKNOWN";
        }
    }

    bool operator==(const Side& side2) const {
        return side == side2.side;
    }

    bool operator!=(const Side& side2) const {
        return side != side2.side;
    }

private:
    Type side;  // The enum value
};


struct Order {
    /* 
    A basic Order type used by an Exchange to conduct trades or maintain an order book.

    This should not be confused with order Messages agents send to request an Order.
    Specific order types will inherit from this (like LimitOrder).
    */

    static int order_id_counter;
    int agentID;
    Timestamp time_placed;
    std::string symbol;
    int quantity;
    Side side;
    std::optional<int> order_id;
    int fill_price;

    Order() {}

    Order(
        int agentID,
        Timestamp time_placed,
        std::string symbol,
        int quantity,
        Side side,
        std::optional<int> order_id = std::nullopt
    ) : agentID(agentID), time_placed(time_placed), symbol(symbol),
        quantity(quantity), side(side) {
        /*
        Arguments:
            agent_id: The ID of the agent that created this order.
            time_placed: Time at which the order was created by the agent.
            symbol: Equity symbol for the order.
            quantity: Number of equity units affected by the order.
            side: Indicates if an order is on the BID or ASK side of the market.
            order_id: Either self generated or assigned. Should only be self
            generated by the OrderBook class.
            tag: A free-form user-defined field that can contain any information
                relevant to the entity placing the order.  Recommend keeping it
                alphanumeric rather than shoving in objects, as it will be there
                taking memory for the lifetime of the order and in all logging
                mechanisms.  Intent: for strategy agents to set tags to help keep
                track of the intent of particular orders, to simplify their code.
        */

        if (!order_id.has_value()) {
            order_id = order_id_counter;
            order_id_counter ++;
        }

        // Create placeholder fields that don't get filled in until certain events happen.
        fill_price = -1;
        }
};


struct LimitOrder : public Order {
    /*
    LimitOrder class that inherits from Order class and adds a limit price and a
    hidden order flag.

    These are the Orders that typically go in an Exchange's OrderBook.
    */

    int limit_price;
    bool is_hidden;
    bool is_price_to_comply;
    bool insert_by_id;
    bool is_post_only;

    LimitOrder(
        int agentID,
        Timestamp time_placed,
        std::string symbol,
        int quantity,
        Side side,
        int limit_price,
        bool is_hidden = false,
        bool is_price_to_comply = false,
        bool insert_by_id = false,
        bool is_post_only = false,
        std::optional<int> order_id = std::nullopt
    ) : Order(agentID, time_placed, symbol, quantity, side, order_id),
        limit_price(limit_price), is_hidden(is_hidden), is_price_to_comply(is_price_to_comply),
        insert_by_id(insert_by_id), is_post_only(is_post_only) {}

    LimitOrder() {}

    // Overload the '<<' operator to convert Order to a string representation
    friend std::ostream& operator<<(std::ostream& os, const LimitOrder& order) {
        // Until we make explicit market orders, we make a few assumptions that EXTREME prices on limit
        // orders are trying to represent a market order.  This only affects printing - they still hit
        // the order book like limit orders, which is wrong.
        std::string price = std::abs(order.limit_price) < std::numeric_limits<int>::max() ? dollarise(order.limit_price) : "MKT";
        std::string filled = order.fill_price != -1 ? "" : "(filled @ " + dollarise(order.fill_price) + ")";

        os << "(Agent " << order.agentID << " @ " << order.time_placed.to_string() << 
        ") " << order.side.to_string() << " " << order.quantity << " " << order.symbol <<
        " @ " << price << " " << filled;
        return os;
    }
};

struct MarketOrder : public Order {
    /*
    MarketOrder class, inherits from Order class.
    */

    MarketOrder(
        int agentID,
        Timestamp time_placed,
        std::string symbol,
        int quantity,
        Side side,
        std::optional<int> order_id = std::nullopt
    ) : Order(agentID, time_placed, symbol, quantity, side, order_id) {}


    friend std::ostream& operator<<(std::ostream& os, const MarketOrder& order) {
        os << "(Agent " << order.agentID << " @ " << order.time_placed.to_string() << ") : MKT Order "
           << order.side.to_string() << " " << order.quantity << " " << order.symbol;

        return os;
    }

};